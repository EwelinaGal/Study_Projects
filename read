#include <iostream>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
//Napisać dwa programy, które komunikują się ze sobą za pomocą łączy:

//Program łącze1 łącze2

//Każdy z programów otwiera łącza lub tworzy je, jeśli nie istnieją. Procesy odczytują wiadomości z terminala (standardowe wejście stdout) oraz z łącza.
//Wiadomości odczytane z terminala przesyłane są przez łącze do drugiego procesu. Wiadomości odczytane z łącza są wyświetlane na terminalu (standardowe wyjście stdout).
//Zalecane jest wykorzystanie funkcji select().

using namespace std;

//Pierwszy parametr przechowuje liczbę argumentów przekazanych w wierszu poleceń, a drugi jest
//tablicą wskaźników do napisów będących tymi argumentami. Argumenty te mogą być całkowicie
//dowolnymi napisami.
//Trzeci argument funkcji main() to wskaźnik na tablicę napisów tworzących środowisko. W przypadku środowiska istnieje wymaganie, aby każdy z napisów miał postać zmienna=wartość.

void write_from_fifo(int fd)
{
    char message[100]; //message do 100 znakow

    
    if (write(fd, message, sizeof(message)) < 0) // funkcja read z lacza, wiadomosc do 100 znakow, jesli mniejsze od zera, tzn stdin -> odczytaj z lacza
        perror("read");                         // jesli blad: Bad file descriptor
                             
    else
    {
        printf("Message to send: %s \n", message);
    }
};

void read_from_fifo(int fd)
{
    char message[10];                           //message do 100 znakow
    if (read(fd, message, sizeof(message)) < 0) // funkcja read z lacza
        perror("read");                         // jesli blad: Bad file descriptor
    cout <<   "errorrrrrr2" << endl;    
    else
    {

        printf("Message received: %s \n", message);
    }
};

int make_open_wrfifo(char const *myfifo)
{
    mkfifo(myfifo, 0666);

    int fd = open(myfifo, O_WRONLY);
  
    return fd; // zwraca otwarty file descriptor[]
}

int make_open_rdfifo(char const *myfifo)
{
    mkfifo(myfifo, 0666);


    int fd = open(myfifo, O_RDONLY);

    return fd; // zwraca otwarty file descriptor[]
}

int main(int argc, char *argv[], char *envp[])
{

    printf("Beginning of the program \n");
    printf("PID=%d  RODZIC \n", getpid());

    fd_set fds;

    int readfd1 = make_open_rdfifo(argv[1]);
    
    int writefd2 = make_open_wrfifo(argv[2]);
    

    
    //int stdin = make_open_rdfifo(stdin);
    //int stdout = make_open_wrfifo(stdout);

    // petla sprawdzajaca lacza
    int maxfds = 2;

    while (1)
    {

        FD_ZERO(&fds); // set do czyszczenia zestawu
        FD_SET(readfd2, &fds);
        FD_SET(writefd1, &fds);
        FD_SET(stdin, &fds);
        FD_SET(stdout, &fds);

        // maxfd - max file deskpryptor maksymalny numer
        // dwa lacza

        // select() = number of max stdout / fds, fd_set if read, fd_set if write, fd_set except, time)
        select(maxfds + 1, &fds, NULL, NULL, NULL);
        // FD_ISSET sprawdza czy fd jest w zestawie &fds
        fgets(message, 100, writefd1);
        if (FD_ISSET(readfd2, &fds))
        {
            read_from_fifo(readfd2);
        }
        close(readfd2);
        perror("close");

        if (FD_ISSET(writefd1, &fds))
        {
            write_from_fifo(writefd1);
        }

        close(writefd1);
        perror("close");


        if (FD_ISSET(stdout, &fds))
        {
            read_from_fifo(stdout);
        }

        if (FD_ISSET(stdin, &fds))
        {
            write_from_fifo(stdin);
        }

    }

    /*
    if (close(stdout) < 0)
        perror("close");

    / unlink usuwa potok if (unlink(readfd1) < 0)
            perror("unlink");

    if (unlink(readfd2) < 0)
        perror("unlink");

    if (unlink(stdout) < 0)
        perror("unlink");

    * /

        return 0;
}

/*
1. stworzyć sobie strukturkę fd_set (makro FD_ZERO)
2. dodać do niej deskryptory (twoje łącze i stdout) (makro FD_SET)
3. wywołać select, zablokuje się aż coś się nie pojawi w którymś "pliku"
4. uwaga bo select modyfikuje struktury które podajesz
5. sprawdzasz makrem FD_ISSET po kolei wszystkie dekryptory czy coś czeka
6. czytasz za pomocą read lub czegośtam
7. wysyłasz za pomocą write gdziekolwiek
8. z powrotem do 1
*/
